1. 将条件变量阻塞放到队列中, 这样消费者也可以是生产者.   已经完成
2. 尝试自动调节线程大小, 如果是这样建议使用thread*, 这样增加和销毁产生的花销不大
3. 定义submit返回值类型, 使用using设置一个别名
3. 是否使用优先队列
4. 延时任务是否需要做一下?

支持多任务参数, 一切可调用对象都可以作为线程主函数执行
等待任务执行结果


使用bind会有性能的影响, 原因: 调用栈比较深


hashtable可能需要重新做一下, 安装接口来做. 不然都不成样子.
不行啊, 如果只是这样, 那么是不够的. 是否需要前进一步

* 就业困境
你首先需要认识到, 你已经27了, 你应该找工作了
你已经给过自己三个月了, 不能再给了
不能再这样下去了
别看你看了这么多小说, 以为自己很有知识, 但你不能立即想起来, 那就说明你没有. 
你现在这个情况, 是你没有做好, 怪不得别人. 很多人劝过你, 你也有很多机会, 不过是你没有珍惜而已.
跟你的天赋没有关系, 跟你的付出有关系, 跟你的积累有关系. 一直这么在意天赋, 一直想当个天才, 其实和心里一直有一种一夜暴富的想法和意识有关. 一年才能做好的东西, 恨不得一天就做完.奋斗五六年才能做到的, 恨不得两年做完. 所以学习也好, 做事情也好, 才会这样慌慌忙忙, 做事情顾头不顾尾, 才会才学习10分钟, 就想结束, 不看了呢, 又没有什么要干的呢? 自己毁灭自己.
概念有什么错呢? 用错了而已. 唯物和概念之间的关系.
不要做愤青, 社会父母都没有欠你什么.
我感觉靠编程养活自己是不可能了, 我不喜欢, 又不愿意投入时间
真正在上面花的时间, 连我玩的时间都没有.
精力不要分散. 做一件事就好, 不要想这想那的, 这也想做, 那也想做.
花钱, 花时间和花精力最多的地方, 你肯定比较擅长. 你可能不太愿意, 也不太喜欢, 但这已经成了事实了.

不要做电子仓鼠, 视频存下来不看, 收藏夹里落灰, 说明你不喜欢这件事情, 你不喜欢它里面的内荣, 你知识觉得很厉害, 或者你在假装我很厉害, 不要陷入这么虚假的幻境里面.
喜欢了, 你肯定迫不及待的去做, 如果你没有看过, 那么你最好不要收藏. 
很多道理知识都很不起眼, 不那么高大上, 也不那么抽象晦涩, 但理智和认知就是从这样不起眼, 很明显的地方慢慢的建立起来的.
如果一个网页, 一个视频, 你收藏起来, 你不看, 那说明不是必须的, 也不是你喜欢的. 那么就没有必要留着了
没有什么能一下解决你问题的神药, 药都是慢慢起作用的.
你没学好, 不怪别人.
把未来当成现在, 把或然当成必然. 这是你犯的又一个错误, 这甚至是你常犯的一个错误
所谓盛世, 就是把不可能变成可能, 万事万物都会发生强烈的难以想象的变化, 百年未有之大变局, 需要参与进去啊, 需要参与到项目当中, 需要参与到其中, 成为其中的一员.
有点感受和知道了是两码事, 知道了和去做是两码事, 做了和做成功了又是两码事.
你看, 知道了方法, 照着去做, 啥子和蠢货也能做好.

知识和学习知识的方法是不一样的. 知识和用知识的方法又是不一样的. 对知识的理解不能代替学习知识和使用知识的方法.
不能用对知识的理解代替学习知识的方法和使用知识的方法.

知识你往往会无意识的忽略, 只是因为它不能像夏天的冰泉水一样马上解渴吗. 你这就像是一个濒死的病人要一粒马上就能让他生龙活虎的丹药一样.

学习不能贪多, 需要好好的消化掉, 要精通, 精通的目的是为了应用.

学习问题要靠学习方法来解决，实践问题要靠动手来解决嘛

极尽升华什么的，要不得，不要被忽悠了
还每一阶段，这是死路
以为每一阶段做好就无敌了，实则是一种很死板的发展方式，只要能解决每一阶段的主要矛盾，结果就不会差
不是什么都记，就是根基扎实，基础，根基什么的不懂，也不需要懂。不要胡思乱想. 不要死记硬背.

太慢了
我在Linux上面消耗的时间过多, 本来是想得到一件锋利的武器, 最后反倒本末倒置, 忘记了初心, 耽误了太多的时间.
这样的错误犯过太多次了. 不能这样下去了, 即使是这个月, 做的事情太少了. 不能浪费时间啊.
想要将这些工具的厉害之处发挥出来, 必须得做事啊. 或者反过来说, 只有做事, 才可能发现这些优点.
使用不是目的, 用来做事才是目的. 
不能再晃晃悠悠的了, 必须充分利用手里的时间. 需要有点紧迫感. 不要用理由来安慰自己了.
不能在决策上面浪费太多的时间. 在关键的时候, 做点什么比什么都不做的要好.
很多时候, 照着目标前进, 做和目标强相关的事情, 哪怕进步很小, 坚持下来也会有效果,  反倒是"大跃进", 不但不能达到目的, 反倒有负面影响, 反倒是大倒退.

必须将哲学和具体学科分开. 数学哲学是哲学, 和数学有关, 但不能靠这个学习和研究数学.

在三观上, 在认识上, 一个很小的差异可能导致巨大的差别, 也可能导致及其巨大的错误

作为行为逻辑和思考逻辑基础的三观, 方法论等, 一定不能出现问题, 不然推演到最后的结论可能无法收场

不能忽略问题, 不能放任问题, 特别是关乎自己未来, 自己前途, 自己生死的问题, 不能拖, 一定不能拖, 否则可能发展到自己无论如何也不可能解决, 也来不及解决的问题. 开始的时候克制畏惧, 克制懒惰可能就能解决了, 最后可能再想解决, 再有能力也不可能解决了.

果然啊, 解决的问题的唯一办法就是一直去做, 不论身处什么样的状态, 不论是困倦还是精力充沛, 不论是深处绝望还是充满机会.


** 时间的问题
   毕业已经两年. 尚未有工作经历. 两年了啊, 如果是高中的话, 都过去一大半了. 


** 能力的问题
   学习过的很多内容已经忘记.
   面向对象的一些东西, 模板编程的一些东西. 排序算法, 数据结构
   还有一些东西没学: MySQL. 网络
   还有八股文.
   

** 态度的问题
   得过且过, 浑浑噩噩
   不把找工作当回事情

** 简历的问题
   尚未优化, 不够吸引人的


** 项目的问题:
须速战速决, 不可能等到全部写完了.
我必须先写一个可以说明的项目, 没写完, 那么就不放链接
投递简历, 检查意向. 投石问路.
之后做的就是完善简历, 同时想想沟通过程怎么说.
    1. 怎么说两年没有工作
    2. 怎么说项目的优缺点.
    3. 我对工作的报酬是什么.
    4. 背诵八股文, 数据结构和算法. 学习MySQL

*** 需要做
    unordered_map
    map
    string

**** 非必须, 有更好
    unordered_multimap
    unordered_set
    unordered_multset
    set
    map


*** 必须有的
    pair
    vector
    stack
    list
    queue
    string
    map
    hashtable
    sort
    string
    

*** 关于实现
    需要解决的问题:
        1. hashtable是怎么实现的? 是pair式的还是单个T, 如果是, 应该如何封装
           在unordered_map和unordered_multimap中, 声明使用 pair.
               1). STL 是如何用一个模板变量来代替pair的?
                   T是一个模板参数, pair 可以当成一个类型
               2). 既然只有一个模板变量来控制元素, 那么哈希值是如何得到的?
                   这里hash函数怎么实现的不重要, 重要的是如何调用的. 因为 hash 函数实现的必定是传入一个参数进去.
                   而这里需要解决的就是这个参数是怎么得来的, 这只能通过查看调用者才能实现.

                   这里需要注意insert_unique_noresize insert_multi_noresize erase  这两个函数. 调用了hash函数

                   这些参数是什么, 如何能够得到哈希值. 
                   const auto n = hash(value_traits::get_key(value));
                   hash(value_traits::get_key(first.node->value))


                   erase_unique(const key_type& key) 中, key_type 又是什么? 可以通过   const auto n = hash(key); 来调用 hash函数

                   

                   什么? 居然是T? 只有一个模板参数?
               哈希值来自两个方面, 要么%n, 要么%桶的数量.
        2. 它的接口是如何设计的, 让undorder_map和undorder_multimap都可以使用?
           其余所有的东西都是使用 hashtable 的接口实现的. 现在重点在hashtable上面
        3. hash 函数如何设计的, rehash函数又如何设计的?
           对于浮点数是否可以使用通用哈希函数来做呢? 诸位哈希的办法虽然就在这里, 但属实有点看不懂.
           而且我也不想和别人一模一样. bitwise_hash
        4. 如果是multi和map同一个底层数据结构, 那么需要在此数据结构中准备好multi和map
        5. 使用vector容器, 好扩展
        使用的接口, 而且需要注意的是, 它们的接口是不一样的.

    unordered_map, 不去管具体实现了, 反正都需要封装, 看看怎么封装才好.
    找一个实现比较详细完全的, 抄也好抄一点.

类中的插入函数:
    hashtable<T, Hash, KeyEqual>::                        ==>
    insert_unique_noresize(const value_type& value)
    const auto n = hash(value_traits::get_key(value));


类: 
    template <class T, class Hash, class KeyEqual>
    class hashtable:

    typedef ht_value_traits<T>                          value_traits;       ==>
    typedef typename value_traits::key_type             key_type;


调用的类:
    template <class T>
    struct ht_value_traits

    typedef ht_value_traits_imp<T, is_map> value_traits_type;
 
    typedef typename value_traits_type::key_type    key_type;
 
    template <class Ty>
    static const key_type& get_key(const Ty& value)                          ==>
    {
      return value_traits_type::get_key(value);
    }

调用的类:

    template <class T>
    struct ht_value_traits_imp<T, true>
    {
      typedef typename std::remove_cv<typename T::first_type>::type key_type;
      typedef typename T::second_type                               mapped_type;
      typedef T                                                     value_type;
    
      template <class Ty>
      static const key_type& get_key(const Ty& value)
      {
        return value.first;
      }

 
草了, 原来是一开始就使用了pair, 写那么多层干什么, 好玩啊?










*** MySTL要求: 
	1. 需要能编译通过
	2. 需要测试接口
	3. 可能需要添加一些东西, 比如map封装了红黑树, 那么我们是否可以将红黑树封装成map?(非必须)
    4. 对于排序算法, 可以用一下我写的测试框架.稍微改一下, 增加一点代码量.
    

*** MySTL问题
现在的问题:
	1. 如果需要修改, 那么很难
	2. 过去的时间太长了, 很多东西不记得了.
	3. 内容很杂, 而课本又没有详细解释
    4. STL有些什么, 需要做什么, 不需要做什么, 不清楚

优点:
	1. 我做了vector, list. 






* 尝试
我今年年初的时候尝试
结果: 失败
失败的原因: 偷懒, 不敢去做.
            有时候明明问题就在哪里, 害怕, 不敢去碰
            不论是看小说, 摆弄Linux都是一种逃避的手段.

一直拖着, 我有了个问题, 不去解决, 以为要解决某某问题才能继续走下去, 最后呢? 自己也没有解决这个问题, 然后就这样拖着了. 
本来可以马上解决的问题, 非要写看小说, 打字, 激情磨尽, 然后就一直拖下去了.


* 关于这三个月来的反思

** 习惯问题
懒惰
没有就业意向
没有危机感, 手里有钱就狂欢

** 作息问题
为了避免思考未来, 你宁愿看小说熬夜, 也不愿尝试一下. 熬夜之后也没有精力去处理事情, 恶性循环

** 性格问题
浪费了时间, 错过了时机, 不想着弥补和挽救, 反到自甘堕落, 自暴自弃, 得过且过

** 时间和职业规划
完全没有把握时机的觉悟
完全封闭自己, 封闭信息来源, 躲在自己的世界里, 拆掉自己爬出深渊的梯子取火

** 思想上的问题
线性的做事情, 这是十年来最明显的, 却也是最不容易发现的问题.
只有一件事做好了才做一件事, 如果阻塞了, 就死磕一件事情. 做事情是这样, 学习也是这样.
这样做, 会有安全感, 会有爽感, 自己心里也舒服. 但就是不能做成事情, 十年的经验教训告诉我了.
可学习结果不受意志控制, 那么有没有安全感都是一样的, 只不过过程有点差别, 结果好就行了. 
这是不对的, 一件事情陷入了僵局, 那么就做另一件事情. 以此类推, 总有能做的.

** 心理问题
想着一来就选个好工作, 但学历和能力是不支持的, 忽视了自身的条件
但我真的不希望, 一辈子就是发快递, 电子厂. 做了什么就是什么样的人. 我怕我到时候脱不开身. 走不出去.
父亲太天真, 哪有老板不榨干你的时间的? 至少十天的工作经验是这样的.
我有机会没把握住和没有这个条件是两回事情.
害怕就业

** 金钱
自己对金钱的使用没有概念, 或者说, 拒绝接受这个事实.
花钱没度

** 机会
你有那么多次认清现实的机会, 却不承认, 宁愿将头埋在沙子里面, 不承认却又无法证明
很多时候你知道了问题, 也知道怎么解决, 但是却置之不理, 似乎一切都会好起来, 但事实却并非这样.

